{"version":3,"names":[],"mappings":"","sources":["grid-board-view.js"],"sourcesContent":["(function() {\n\t\n\tvar JOCLY_FIELD_SIZE=12000; // physical space\n\n\tvar NBCOLS=0, NBROWS=0, CSIZES={};\n\t\n\tView.Game.cbEnsureConstants =function() {\n\t\tif(NBROWS)\n\t\t\treturn;\n\t\tNBROWS=this.cbVar.geometry.height;\n\t\tNBCOLS=this.cbVar.geometry.width;\n\t}\n\t\n\t// 'this' is a Game object\n\tView.Game.cbCSize =function(boardSpec) {\n\t\tthis.cbEnsureConstants();\n\t\tvar cSize=CSIZES[boardSpec.margins.x+\"_\"+boardSpec.margins.y];\n\t\tif(!cSize) {\n\n\t\t\tvar ratio,width,height,cellSize;\n\t\t\t\n\t\t\tvar relWidth = NBCOLS+2*boardSpec.margins.x;\n\t\t\tvar relHeight = NBROWS+2*boardSpec.margins.y;\n\t\t\t\n\t\t\tratio =  relWidth / relHeight;\n\t\t\tif(ratio<1)\n\t\t\t\tcellSize = (JOCLY_FIELD_SIZE * ratio) / relWidth;\n\t\t\telse \n\t\t\t\tcellSize = (JOCLY_FIELD_SIZE / ratio) / relHeight;\n\t\t\twidth = (NBCOLS+2*boardSpec.margins.x) * cellSize;\n\t\t\theight= (NBROWS+2*boardSpec.margins.y) * cellSize;\n\t\t\t\n\t\t\t/* useful ?\n\t\t\tvar pieceCx=1.0*cx;\t\t\t\n\t\t\tvar pieceCy=pieceCx/1.0;\n\t\t\tif (pieceCy>pieceScale2D*cy){\n\t\t\t\tpieceCy=pieceScale2D*cy;\n\t\t\t\tpieceCx=this.g.pieceRatio*cy;\n\t\t\t}\n\t\t\t*/\n\t\t\tcSize={\n\t\t\t\tcx:cellSize,\n\t\t\t\tcy:cellSize,\n\t\t\t\tpieceCx:cellSize,\n\t\t\t\tpieceCy:cellSize,\n\t\t\t\tratio: ratio,\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t}\n\t\t\tCSIZES[boardSpec.margins.x+\"_\"+boardSpec.margins.y]=cSize;\n\t\t}\n\t\treturn cSize;\n\t}\n\t\n\tView.Game.cbGridBoard = $.extend({},View.Game.cbBaseBoard,{\n\t\t\n\t\tnotationMode: \"out\", // notation outside the board\n\t\t\n\t\t// 'this' is a Game object\n\t\tcoordsFn: function(boardSpec) {\n\t\t\t\n\t\t\tboardSpec = boardSpec || {};\n\t\t\tboardSpec.margins = boardSpec.margins || {x:0,y:0};\n\t\t\t\n\t\t\treturn function(pos) {\n\t\t\t\tvar cSize = this.cbCSize(boardSpec);\n\t\t\t\tvar c=pos%NBCOLS;\n\t\t\t\tvar r=(pos-c)/NBCOLS;\n\t\t\t\tif(this.mViewAs==1)\n\t\t\t\t\tr=NBROWS-1-r;\n\t\t\t\tif(this.mViewAs==-1)\n\t\t\t\t\tc=NBCOLS-1-c;\n\t\t\t\tvar coords={\n\t\t\t\t\tx:(c-(NBCOLS-1)/2)*cSize.cx,\n\t\t\t\t\ty:(r-(NBROWS-1)/2)*cSize.cy,\n\t\t\t\t\tz:0,\n\t\t\t\t};\n\t\t\t\t//console.warn(\"coord\",pos,\"=\",coords)\n\t\t\t\treturn coords;\n\t\t\t}\n\t\t},\n\t\t\n\t\tcreateGeometry: function(spec,callback) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tvar cx=cSize.width/1000;\n\t\t\tvar cy=cSize.height/1000;\n\t\t\tvar geo = new THREE.PlaneGeometry(cx,cy);\n\t\t\t\n\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\tmatrix.makeRotationX(-Math.PI/2)\n\t\t\tgeo.applyMatrix(matrix);\n\t\t\t\n\t\t\tvar uvs=geo.faceVertexUvs[0];\n\t\t\tfor (var u = 0 ; u < uvs.length ; u++){\n\t\t\t\tfor (var i = 0 ; i < uvs[u].length ; i++){\n\t\t\t\t\tif(cSize.ratio<1)\n\t\t\t\t\t\tuvs[u][i].x=uvs[u][i].x*cSize.ratio+(1-cSize.ratio)/2;\n\t\t\t\t\tif(cSize.ratio>1)\n\t\t\t\t\t\tuvs[u][i].y=uvs[u][i].y/cSize.ratio+(1-1/cSize.ratio)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcallback(geo);\n\t\t},\n\n\t\tpaintBackground: function(spec,ctx,images,channel,bWidth,bHeight) {\n\t\t\tif (images['boardBG'])\n\t\t\t\tctx.drawImage(images['boardBG'],-bWidth/2,-bHeight/2,bWidth,bHeight);\t\t\t\t\n\t\t},\t\t\n\n\t\tpaintChannel: function(spec,ctx,images,channel) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tspec.paintBackground.call(this,spec,ctx,images,channel,cSize.width,cSize.height);\t\t\t\n\t\t},\n\t\t\n\t\tpaint: function(spec,canvas,images,callback) {\n\t\t\tfor(var channel in canvas) {\n\t\t\t\tvar ctx=canvas[channel].getContext('2d');\n\t\t\t\tctx.save();\n\t\t\t\tctx.scale(spec.TEXTURE_CANVAS_CX/JOCLY_FIELD_SIZE,spec.TEXTURE_CANVAS_CY/JOCLY_FIELD_SIZE);\n\t\t\t\tctx.translate(JOCLY_FIELD_SIZE/2,JOCLY_FIELD_SIZE/2);\n\t\t\t\tspec.paintChannel.call(this,spec,ctx,images,channel);\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t\tcallback();\n\t\t},\n\n\n\t});\n\n\tView.Game.cbGridBoardClassic = $.extend({},View.Game.cbGridBoard,{\n\t\t'colorFill' : {\t\t\n\t\t\t\".\": \"rgba(160,150,150,0.9)\", // \"white\" cells\n\t\t\t\"#\": \"rgba(0,0,0,1)\", // \"black\" cells\n\t\t\t\" \": \"rgba(0,0,0,0)\",\n\t\t},\n\t\t'texturesImg' : {\n\t\t\t'boardBG' : '/res/images/wood.jpg',\n\t\t},\n\t\tmodifyMesh: function(spec,mesh,callback) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tvar cx=cSize.width/1000;\n\t\t\tvar cy=cSize.height/1000;\n\n\t\t\t// add border frame\n\t\t\tfunction setupShapeSquare(cx,cy){\n\t\t\t\tvar sh = new THREE.Shape();\n\t\t\t\tsh.moveTo(-cx/2 , -cy/2);\n\t\t\t\tsh.lineTo(cx/2 , -cy/2);\n\t\t\t\tsh.lineTo(cx/2 , cy/2);\n\t\t\t\tsh.lineTo(-cx/2 , cy/2);\n\t\t\t\treturn sh;\t\t\n\t\t\t}\t\t\t\t\t\n\t\t\tvar bevelSize = .1;\n\t\t\tvar frameWidth=0.5;\n\t\t\tvar frameShape = setupShapeSquare(cx+frameWidth+bevelSize, cy+frameWidth+bevelSize);\n\t\t\tvar holeShape = setupShapeSquare(cx+bevelSize,cy+bevelSize);\n\t\t\tframeShape.holes.push(holeShape);\n\n\t\t\tvar extrudeSettings = {\n\t\t\t\tamount: .4 , // main extrusion thickness\n\t\t\t\tsteps: 1 , // nb of main extrusion steps\n\t\t\t\tbevelSize: bevelSize, \n\t\t\t\tbevelThickness:.04,\n\t\t\t\tbevelSegments: 1, // nb of bevel segment\n\t\t\t};\n\n\t\t\tvar frameGeo = new THREE.ExtrudeGeometry( frameShape, extrudeSettings );\n\t\t\t\n\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\tmatrix.makeRotationX(-Math.PI/2)\n\t\t\tframeGeo.applyMatrix(matrix);\n\t\t\t\n\t\t\tblackMat = new THREE.MeshPhongMaterial({\n\t\t\t\tcolor: '#000000',\n\t\t\t\tshininess: 500,\n\t\t\t\tspecular: '#888888',\n\t\t\t\temissive: '#000000',\n\t\t\t\t//ambient: '#000000',\n\t\t\t});\n\t\t\tvar frameObj = new THREE.Mesh( frameGeo , blackMat);\n\t\t\tframeObj.position.y=-extrudeSettings.amount-.01;\n\t\t\tmesh.add(frameObj);\n\t\t\tvar bottom = new THREE.Mesh(new THREE.BoxGeometry(cx,cy,0.1),blackMat);\n\t\t\tbottom.rotation.x=Math.PI/2;\n\t\t\tbottom.position.y=-.1;\n\t\t\tmesh.add(bottom);\n\t\t\tcallback(mesh);\n\t\t},\n\t\t\n\t\tpaintCell: function(spec,ctx,images,channel,cellType,xCenter,yCenter,cx,cy) {\n\t\t\tctx.strokeStyle = \"rgba(0,0,0,1)\";\n\t\t\tctx.lineWidth = 15;\n\t\t\tif (channel=='bump')\n\t\t\t\tctx.fillStyle=\"#ffffff\";\n\t\t\telse\n\t\t\t\tctx.fillStyle=spec.colorFill[cellType];\n\t\t\tctx.fillRect(xCenter-cx/2,yCenter-cy/2,cx,cy);\n\t\t\tctx.rect(xCenter-cx/2,yCenter-cy/2,cx,cy);\n\t\t},\n\t\t\n\t\tpaintCells: function(spec,ctx,images,channel) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tvar getCoords=spec.coordsFn(spec);\n\t\t\tfor(var row=0;row<NBROWS;row++) {\n\t\t\t\tfor(var col=0;col<NBCOLS;col++) {\n\t\t\t\t\tvar pos = this.mViewAs==1 ?\n\t\t\t\t\t\tcol+row*NBCOLS :\n\t\t\t\t\t\tNBCOLS*NBROWS-(1+col+row*NBCOLS);\n\t\t\t\t\tvar coords=getCoords.call(this,pos);\n\t\t\t\t\tvar cellType=this.cbView.boardLayout[NBROWS-row-1][col];\n\t\t\t\t\tvar xCenter=coords.x;\n\t\t\t\t\tvar yCenter=coords.y;\n\t\t\t\t\tvar cx=cSize.cx;\n\t\t\t\t\tvar cy=cSize.cy;\n\t\t\t\t\t\n\t\t\t\t\tspec.paintCell.call(this,spec,ctx,images,channel,cellType,xCenter,yCenter,cx,cy);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\tpaintLines: function(spec,ctx,images,channel) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tctx.strokeStyle = \"#000000\";\n\t\t\tctx.lineWidth = 40;\n\t\t\tctx.strokeRect(-NBCOLS*cSize.cx/2,-NBROWS*cSize.cy/2,NBCOLS*cSize.cx,NBROWS*cSize.cy);\n\t\t},\n\n\t\tpaintChannel: function(spec,ctx,images,channel) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tspec.paintBackground.call(this,spec,ctx,images,channel,cSize.width,cSize.height);\n\t\t\tspec.paintCells.call(this,spec,ctx,images,channel)\n\t\t\tspec.paintLines.call(this,spec,ctx,images,channel);\n\t\t\tif(this.mNotation)\n\t\t\t\tspec.paintNotation.call(this,spec,ctx,channel);\n\t\t},\n\t\t\n\t\tpaintNotation: function(spec,ctx,channel) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tctx.textAlign = 'center';\n\t\t\tctx.textBaseline = 'middle';\n\t\t\tctx.fillStyle = \"#000000\";\n\t\t\tctx.font = Math.ceil(cSize.cx / 3) + 'px Monospace';\n\t\t\tswitch(spec.notationMode) {\n\t\t\tcase \"out\":\n\t\t\t\tspec.paintOutNotation.apply(this,arguments);\n\t\t\t\tbreak;\n\t\t\tcase \"in\":\n\t\t\t\tspec.paintInNotation.apply(this,arguments);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\t\t\n\t\tpaintOutNotation: function(spec,ctx,channel) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tfor (var row = 0; row < NBROWS; row++) {\n\t\t\t\tvar displayedRow = NBROWS - row;\n\t\t\t\tif(this.mViewAs<0)\n\t\t\t\t\tdisplayedRow=row+1;\n\t\t\t\tvar x = -(NBCOLS/2 + spec.margins.x/2) * cSize.cx;\n\t\t\t\tvar y = (row-NBROWS/2+.5) * cSize.cy;\n\t\t\t\tctx.fillText(displayedRow, x, y);\t\n\t\t\t}\n\t\t\tfor (var col = 0; col < NBCOLS; col++) {\n\t\t\t\tvar displayedCol=col;\n\t\t\t\tif(this.mViewAs<0)\n\t\t\t\t\tdisplayedCol = NBCOLS - col -1;\n\t\t\t\tvar x = (col-NBCOLS/2+.5) * cSize.cx;\n\t\t\t\tvar y = (NBROWS/2 + spec.margins.y/2) * cSize.cy;\n\t\t\t\tctx.fillText(String.fromCharCode(97 + displayedCol), x , y);\n\t\t\t}\n\t\t},\n\t\t\n\t\tpaintInNotation: function(spec,ctx,channel) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tvar getCoords=spec.coordsFn(spec);\n\t\t\tvar fills=spec.colorFill;\n\t\t\tctx.font = Math.ceil(cSize.cx / 5) + 'px Monospace';\n\t\t\tfor (var row = 0; row < NBROWS; row++) {\n\t\t\t\tfor (var col = 0; col < NBCOLS; col++) {\n\t\t\t\t\tvar displayedRow=NBROWS - row;\n\t\t\t\t\tvar displayedCol=col;\n\t\t\t\t\tif(this.mViewAs<0)\n\t\t\t\t\t\tdisplayedCol = NBCOLS - col -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tdisplayedRow=row+1;\t\t\t\t\t\t\t\t\n\t\t\t\t\tvar pos = this.mViewAs==1 ?\n\t\t\t\t\t\t\tcol+row*NBCOLS :\n\t\t\t\t\t\t\tNBCOLS*NBROWS-(1+col+row*NBCOLS);\n\t\t\t\t\tvar coords=getCoords.call(this,pos);\n\t\t\t\t\tctx.fillStyle=\"rgba(0,0,0,0)\";\n\t\t\t\t\tif(channel==\"bump\")\n\t\t\t\t\t\tctx.fillStyle = fills[\".\"];\n\t\t\t\t\tswitch(this.cbView.boardLayout[NBROWS-row-1][col]) {\n\t\t\t\t\tcase \".\":\n\t\t\t\t\t\tctx.fillStyle= (channel==\"bump\") ? fills[\".\"] : fills[\"#\"];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"#\":\n\t\t\t\t\t\tctx.fillStyle=fills[\".\"];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvar x = coords.x-cSize.cx / 3;\n\t\t\t\t\tvar y = coords.y-cSize.cy / 3;\n\t\t\t\t\tif(spec.notationDebug)\n\t\t\t\t\t\tctx.fillText(pos,x,y);\n\t\t\t\t\telse\n\t\t\t\t\t\tctx.fillText(String.fromCharCode(97 + displayedCol) + displayedRow,x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t});\n\t\n\tView.Board.cbMoveMidZ = function(aGame,aMove,zFrom,zTo) {\n\t\tvar geometry = aGame.cbVar.geometry;\n\t\tvar x0 = geometry.C(aMove.f);\n\t\tvar x1 = geometry.C(aMove.t);\n\t\tvar y0 = geometry.R(aMove.f);\n\t\tvar y1 = geometry.R(aMove.t);\n\t\tif(x1-x0==0 || y1-y0==0 || Math.abs(x1-x0)==Math.abs(y1-y0))\n\t\t\treturn (zFrom+zTo)/2;\n\t\telse\n\t\t\treturn Math.max(zFrom,zTo)+1500;\n\t}\n\n\tView.Game.cbGridBoardClassic2D = $.extend({},View.Game.cbGridBoardClassic,{\n\t\t'colorFill' : {\t\t\n\t\t\t\".\": \"#F1D9B3\", // \"white\" cells\n\t\t\t\"#\": \"#C7885D\", // \"black\" cells\n\t\t\t\" \": \"rgba(0,0,0,0)\",\n\t\t},\n\t});\n\n\tView.Game.cbGridBoardClassic3DMargin = $.extend({},View.Game.cbGridBoardClassic,{\n\t\t'margins' : {x:.67,y:.67},\n\t\t'extraChannels':[ // in addition to 'diffuse' which is default\n\t\t\t'bump'\n\t\t],\n\t\t/*\n\t\t'mesh': { // not implemented yet\n\t\t\tjsfile:\"/res/xd-view/meshes/taflboard.js\",\n\t\t\tmeshScale:1.32,\n\t\t\tboardMaterialName:\"board\",\n\t\t}\n\t\t*/\n\t});\n\t\n\tView.Game.cbGridBoardClassic2DMargin = $.extend({},View.Game.cbGridBoardClassic2D,{\n\t\t'margins' : {x:.67,y:.67},\n\t});\n\n\tView.Game.cbGridBoardClassic2DNoMargin = $.extend({},View.Game.cbGridBoardClassic2D,{\n\t\t'margins' : {x:0.0,y:0.0},\n\t\t'notationMode': 'in',\n\t\t'texturesImg' : {\n\t\t\t'boardBG' : '/res/images/whitebg.png',\n\t\t},\n\t});\n\n\t\n\t\n})();\n"],"file":"makruk-view.js"}