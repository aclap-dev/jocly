{"version":3,"names":[],"mappings":"","sources":["scrum-model.js"],"sourcesContent":["/*\n *\n * Copyright (c) 2012 - Jocly - www.jocly.com\n * \n * This file is part of the Jocly game platform and cannot be used outside of this context without the written permission of Jocly.\n * \n */\n\n/* Optional method.\n * Called when the game is created.\n */\nModel.Game.InitGame = function() {\n\tvar WIDTH=this.mOptions.width;\n\tvar HEIGHT=this.mOptions.height;\n\tvar g=[];\n\tvar coord=[];\n\tfor(var r=0;r<HEIGHT;r++) {\n\t\tfor(var c=0;c<WIDTH;c++) {\n\t\t\tvar pos=r*WIDTH+c;\n\t\t\tcoord[pos]=[r,c];\n\t\t\tg[pos]=[];\n\t\t\tfor(var h=-1;h<2;h++)\n\t\t\t\tfor(var v=-1;v<2;v++) {\n\t\t\t\t\tif(h!=0 || v!=0) {\n\t\t\t\t\t\tif(r+h<HEIGHT && r+h>=0 && c+v<WIDTH && c+v>=0)\n\t\t\t\t\t\t\tg[pos].push((r+h)*WIDTH+c+v);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tg[pos].push(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n\tthis.g.Graph=g;\n\tthis.g.Coord=coord;\n\tthis.zobrist=new JocGame.Zobrist({\n\t\tboard: {\n\t\t\ttype: \"array\",\n\t\t\tsize: this.g.Graph.length,\n\t\t\tvalues: [\"1\",\"-1\",\"-2\"],\n\t\t}\n\t});\n\n}\n\n/* Optional method.\n * Called when the game is over.\n */\nModel.Game.DestroyGame = function() {\n}\n\n// walk through neighbor positions\nModel.Game.ScrumEachDirection = function(pos,fnt) {\n\tfor(var i=0;i<8;i++) {\n\t\tvar npos=this.g.Graph[pos][i];\n\t\tif(npos!=null)\n\t\t\tfnt(npos,i);\n\t}\n}\n\n/* Constructs an instance of the Move object for the game.\n * args is either an empty object ({}), or contains the data passed to the InitUI parameter.\n */\nModel.Move.Init = function(args) {\n\t//JocLog(\"Move.Init\",args);\n\tif(typeof(args.seg)!=\"undefined\") {\n\t\tthis.seg=[{\n\t\t\tf: args.seg[0].f, // first segment, piece from\n\t\t\tt: args.seg[0].t, // first segment, piece to\n\t\t}];\n\t\tif(typeof(args.seg[0].b)!=\"undefined\")\n\t\t\tthis.seg[0].b=args.seg[0].b; // first segment, ball to\n\t\tif(typeof(args.seg[1])!=\"undefined\") {\n\t\t\tthis.seg[1]={\n\t\t\t\tf: args.seg[1].f, // second segment, piece from\n\t\t\t\tt: args.seg[1].t, // second segment, piece to\n\t\t\t};\n\t\t\tif(typeof(args.seg[1].b)!=\"undefined\")\n\t\t\t\tthis.seg[1].b=args.seg[1].b; // second segment, ball to\n\t\t}\n\t}\n}\n\n/* Optional method.\n * Returns a string to represent the move for display to human. If not defined JSON is used.\n */\nModel.Move.ToString = function() {\n\tvar str=this.seg[0].f+\">\"+this.seg[0].t;\n\tif(typeof(this.seg[0].b)!=\"undefined\")\n\t\tstr+=\">\"+this.seg[0].b;\n\tif(typeof(this.seg[1])!=\"undefined\") {\n\t\tstr+=\" - \"+this.seg[1].f+\">\"+this.seg[1].t;\n\t\tif(typeof(this.seg[1].b)!=\"undefined\")\n\t\t\tstr+=\">\"+this.seg[1].b;\n\t}\n\treturn str;\n}\n\n/* Board object constructor.\n */\nModel.Board.Init = function(aGame) {\t\n\tthis.zSign=0;\n}\n\nModel.Board.InitialPosition = function(aGame) {\n\tvar WIDTH=aGame.mOptions.width;\n\tvar HEIGHT=aGame.mOptions.height;\n\tvar INITIAL=aGame.mOptions.initial;\n\t\n\tthis.first=true;\n\n\tthis.board=[]; // access pieces by position\n\tfor(var r=0;r<HEIGHT;r++) {\n\t\tfor(var c=0;c<WIDTH;c++)\n\t\t\tthis.board[r*WIDTH+c]=-1;\n\t}\n\n\tthis.pieces=[]; // access pieces by index\n\tvar index=0;\n\tfor(var i in INITIAL.a) {\n\t\tvar p=INITIAL.a[i];\n\t\tvar pos=p[0]*WIDTH+p[1];\n\t\tthis.pieces.push({\n\t\t\ts: JocGame.PLAYER_A, // side\n\t\t\tp: pos, // position\n\t\t\ta: 180,\n\t\t\tsc: false,\n\t\t});\n\t\tthis.board[pos]=index++;\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",\"1\",pos);\n\t}\n\tfor(var i in INITIAL.b) {\n\t\tvar p=INITIAL.b[i];\n\t\tvar pos=p[0]*WIDTH+p[1];\n\t\tthis.pieces.push({\n\t\t\ts: JocGame.PLAYER_B, // side\n\t\t\tp: pos, // position\n\t\t\ta: 0,\n\t\t\tsc: false,\n\t\t});\n\t\tthis.board[pos]=index++;\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",\"-1\",pos);\n\t}\n\tthis.ball=INITIAL.ball[0]*WIDTH+INITIAL.ball[1];\n\tthis.board[this.ball]=-2;\n\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",\"-2\",this.ball);\n\tthis.scrum=false;\n}\n\n/* Push into the mMoves array, every possible move\n */\nModel.Board.GenerateMoves = function(aGame) {\n\ttry {\n\t\tthis._GenerateMoves(aGame);\n\t} catch(e) {\n\t\tconsole.error(\"GenerateMoves: \"+e);\n\t}\n}\n\nModel.Board._GenerateMoves = function(aGame) {\n\t// generating an exhaustive list of moves (~10K) would badly affect computer thinking\n\t// only a subset of moves must be considered, hence the complexity of the GenerateMoves method\n\t\n\tvar HEIGHT=aGame.mOptions.height;\n\tvar $this=this;\n\tvar time0=new Date().getTime();\n\n\t// === Utility functions ===\n\t\n\t// get distance between 2 positions\n\t// TODO measure impact of caching\n\tvar distCache={};\n\tfunction Dist(p0,p1) {\n\t\tif(p0>p1) {\n\t\t\tvar tmp=p0;\n\t\t\tp0=p1;\n\t\t\tp1=tmp;\n\t\t}\n\t\tvar sign=\"\"+p0+\"/\"+p1;\n\t\tif(typeof(distCache[sign])==\"undefined\") {\n\t\t\tvar coord0=aGame.g.Coord[p0];\n\t\t\tvar coord1=aGame.g.Coord[p1];\n\t\t\tvar d=Math.max(Math.abs(coord0[0]-coord1[0]),Math.abs(coord0[1]-coord1[1]));\n\t\t\tdistCache[sign]=d;\n\t\t}\n\t\treturn distCache[sign];\n\t}\n\n\t// walk through neighbor positions but directed to another position\n\tfunction EachDirectionTo(pos,toPos,strict,fnt) {\n\t\tvar c0=aGame.g.Coord[pos];\n\t\tvar c=aGame.g.Coord[toPos];\n\t\tvar dirs=[0,1,2,3,4,5,6,7];\n\t\tif(c[0]>c0[0]) {\n\t\t\tdirs[0]=-1;\n\t\t\tdirs[1]=-1;\n\t\t\tdirs[2]=-1;\n\t\t\tif(strict) {\n\t\t\t\tdirs[3]=-1;\n\t\t\t\tdirs[4]=-1;\n\t\t\t}\n\t\t} else if(c[0]<c0[0]) {\n\t\t\tdirs[5]=-1;\n\t\t\tdirs[6]=-1;\n\t\t\tdirs[7]=-1;\n\t\t\tif(strict) {\n\t\t\t\tdirs[3]=-1;\n\t\t\t\tdirs[4]=-1;\n\t\t\t}\n\t\t}\n\t\tif(c[1]>c0[1]) {\n\t\t\tdirs[0]=-1;\n\t\t\tdirs[3]=-1;\n\t\t\tdirs[5]=-1;\n\t\t\tif(strict) {\n\t\t\t\tdirs[1]=-1;\n\t\t\t\tdirs[6]=-1;\n\t\t\t}\n\t\t} else if(c[1]<c0[1]) {\n\t\t\tdirs[2]=-1;\n\t\t\tdirs[4]=-1;\n\t\t\tdirs[7]=-1;\n\t\t\tif(strict) {\n\t\t\t\tdirs[1]=-1;\n\t\t\t\tdirs[6]=-1;\n\t\t\t}\n\t\t}\n\t\tfor(var i in dirs) {\n\t\t\tif(dirs[i]!=-1) {\n\t\t\t\tvar npos=aGame.g.Graph[pos][dirs[i]];\n\t\t\t\tif(npos)\n\t\t\t\t\tfnt(npos,i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// walk through each of own pieces\n\tfunction EachPiece(fnt) {\n\t\tfor(var i in $this.pieces) {\n\t\t\tvar piece=$this.pieces[i];\n\t\t\tif(piece.s==$this.mWho)\n\t\t\t\tfnt(i,piece.p);\n\t\t}\n\t}\n\t\n\t// count number of opponents in the neighborhood\n\tvar ballDataCountCache={};\n\tfunction BallDataCount(pos) {\n\t\tif(typeof(ballDataCountCache[pos])==\"undefined\") {\n\t\t\tvar opCount=0;\n\t\t\tvar selfCount=0;\n\t\t\tvar emptyCount=0;\n\t\t\tvar etab=[];\n\t\t\taGame.ScrumEachDirection(pos,function(npos) {\n\t\t\t\tvar cell=$this.board[npos];\n\t\t\t\tif(cell<0) {\n\t\t\t\t\tif(cell==-1) {\n\t\t\t\t\t\temptyCount++;\n\t\t\t\t\t\tetab.push(npos);\n\t\t\t\t\t}\n\t\t\t\t} else if($this.pieces[cell].s==$this.mWho)\n\t\t\t\t\tselfCount++;\n\t\t\t\telse\n\t\t\t\t\topCount++;\n\t\t\t});\n\t\t\tvar counters={\n\t\t\t\te: emptyCount,\n\t\t\t\tetab: etab,\n\t\t\t\ts: selfCount,\n\t\t\t\to: opCount,\n\t\t\t}\n\t\t\tballDataCountCache[pos]=counters;\n\t\t\treturn counters;\n\t\t} else \n\t\t\treturn ballDataCountCache[pos];\n\t}\n\tvar ballDataCount=BallDataCount(this.ball);\n\n\t// get level1 ball moves\n\tvar ballMoves1=[];\n\tvar ballRow=aGame.g.Coord[this.ball][0];\n\taGame.ScrumEachDirection(this.ball,function(pos) {\n\t\tvar cell=$this.board[pos];\n\t\tif(cell==-1) {\n\t\t\tballMoves1.push({\n\t\t\t\tp: pos,\n\t\t\t\tc: BallDataCount(pos),\n\t\t\t\tg: (aGame.g.Coord[pos][0]-ballRow)*$this.mWho\n\t\t\t});\n\t\t}\n\t});\n\n\t// === handling scrum ===\n\tif(this.scrum) {\n\t\tvar scrumExit=-1;\n\t\tvar pieces=[];\n\t\taGame.ScrumEachDirection(this.ball,function(pos) {\n\t\t\tvar cell=$this.board[pos];\n\t\t\tif(cell==-1)\n\t\t\t\tscrumExit=pos;\n\t\t\telse if(cell>=0 && $this.pieces[cell].s==$this.mWho)\n\t\t\t\tpieces.push(cell);\n\t\t});\n\t\tif(scrumExit==-1) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\treturn;\n\t\t}\n\t\tfor(var i in pieces) {\n\t\t\tvar index=pieces[i];\n\t\t\tvar enclosed=true;\n\t\t\taGame.ScrumEachDirection(scrumExit,function(pos) {\n\t\t\t\tvar cell=$this.board[pos];\n\t\t\t\tif(cell==-1 || (cell>=0 && pos==$this.pieces[index].p))\n\t\t\t\t\t\tenclosed=false;\n\t\t\t});\n\t\t\tif(enclosed==false)\n\t\t\t\tthis.mMoves.push({seg:[{\n\t\t\t\t\tf: $this.pieces[index].p,\n\t\t\t\t\tt: $this.ball,\n\t\t\t\t\tb: scrumExit,\n\t\t\t\t}]});\n\t\t}\n\t\tif(pieces.length>0) {\n\t\t\t//JocLog(\"Scrum moves\",this.mMoves);\n\t\t\tif(this.mMoves.length==0) {\n\t\t\t\tthis.mFinished=true;\n\t\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t// === building segments ===\n\t\n\tvar segments=[];\n\n\t\n\t// segments moving the ball \n\taGame.ScrumEachDirection(this.ball,function(pos) {\n\t\tvar cell=$this.board[pos];\n\t\tif(cell>=0 && $this.pieces[cell].s==$this.mWho) {\n\t\t\tfor(var i in ballMoves1) {\n\t\t\t\tvar bm=ballMoves1[i];\n\t\t\t\tvar segment={\n\t\t\t\t\ti: cell,       // piece index\n\t\t\t\t\tf: pos,        // start piece position\n\t\t\t\t\tt: $this.ball, // end piece position\n\t\t\t\t\tb: bm.p,       // ball position\n\t\t\t\t\tc: bm.c,       // # of opponent in ball neighborhood\n\t\t\t\t\tg: bm.g,       // ball row gain\n\t\t\t\t\td: 1,          // distance from piece to ball\n\t\t\t\t}\n\t\t\t\tsegments.push(segment);\n\t\t\t}\n\t\t}\n\t});\n\t\n\t// segments moving piece only\n\tEachPiece(function(index,pos) {\n\t\t\n\t\tfunction AddSegment(pos0,d0) {\n\t\t\tvar segment={\n\t\t\t\ti: index,\n\t\t\t\tf: pos,\n\t\t\t\tt: pos0,\n\t\t\t\tb: null,\n\t\t\t\tc: ballDataCount,\n\t\t\t\tg: 0,\n\t\t\t\td: d0,\n\t\t\t}\n\t\t\tsegments.push(segment);\n\t\t}\n\n\t\tvar dist=Dist(pos,$this.ball);\n\t\tif(dist==1) {\n\t\t\taGame.ScrumEachDirection(pos,function(npos) {\n\t\t\t\tvar cell=$this.board[npos];\n\t\t\t\tif(cell==-1) {\n\t\t\t\t\tvar d=Dist(npos,$this.ball);\n\t\t\t\t\tAddSegment(npos,d);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if(dist<4) {\n\t\t\taGame.ScrumEachDirection(pos,function(npos) {\n\t\t\t\tvar cell=$this.board[npos];\n\t\t\t\tif(cell==-1) {\n\t\t\t\t\tvar d=Dist(npos,$this.ball);\n\t\t\t\t\tAddSegment(npos,d);\n\t\t\t\t}\n\t\t\t});\n\t\t} else { \n\t\t\tEachDirectionTo(pos,$this.ball,false,function(npos) {\n\t\t\t\tvar cell=$this.board[npos];\n\t\t\t\tif(cell==-1) {\n\t\t\t\t\tvar d=Dist(npos,$this.ball);\n\t\t\t\t\tAddSegment(npos,d);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\t\n\t// update segment weights\n\tfor(var i in segments) {\n\t\tvar segment=segments[i];\n\t\tvar weight=\n\t\t\t(8-segment.c.o)*0.125 * 1 +\n\t\t\t(segment.c.s)*0.125 *   1 +\n\t\t\t(segment.g+2)*0.25 *    4 +\n\t\t\t(11-segment.d)*(1/11) * 2 ;\n\t\tif(segment.e==0)\n\t\t\tweight=-1000;\n\t\tif(segment.e==1)\n\t\t\tweight+=1000;\n\t\tif(segment.e==2)\n\t\t\tweight+=2;\n\t\tsegment.w=weight;\n\t}\n\tsegments.sort(function(a,b) {\n\t\treturn b.w-a.w;\n\t});\n\t\t\n\t// generate moves\n\tvar moves=[];  \n\tvar pmoves=[]; // provisioned moves\n\n\tif(this.first) {\n\t\tfor(var i=0;i<aGame.mOptions.levelOptions.MIN_MOVES && i<segments.length;i++) {\n\t\t\tvar seg=segments[i];\n\t\t\tvar move={ seg:[{\n\t\t\t\t\t\tf: seg.f,\n\t\t\t\t\t\tt: seg.t,\n\t\t\t\t}] }\n\t\t\tif(seg.b!=null)\n\t\t\t\tmove.seg[0].b=seg.b;\n\t\t\tmoves.push(move);\n\t\t}\n\t\tthis.mMoves=moves;\n\t\treturn;\n\t}\n\t\n\tvar gotLevel1WinningSegment=false;\n\tfunction AddMove(seg1,seg2) {\n\n\t\tif(seg1.b!=null) {\n\t\t\t// check if winning first segment\n\t\t\tvar ballRow=aGame.g.Coord[seg1.b][0];\n\t\t\tif((ballRow==0 && $this.mWho==JocGame.PLAYER_B) || (ballRow==HEIGHT-1 && $this.mWho==JocGame.PLAYER_A)) {\n\t\t\t\tvar empty=0;\n\t\t\t\taGame.ScrumEachDirection(seg1.b,function(pos) {\n\t\t\t\t\tif($this.board[pos]==-1)\n\t\t\t\t\t\tempty++;\n\t\t\t\t});\n\t\t\t\tif(empty>0) {\n\t\t\t\t\tif(gotLevel1WinningSegment==false) {\n\t\t\t\t\t\tmoves=[];\n\t\t\t\t\t\tgotLevel1WinningSegment=true;\n\t\t\t\t\t}\n\t\t\t\t\tvar move={seg:[{\n\t\t\t\t\t\tf: seg1.f,\n\t\t\t\t\t\tt: seg1.t,\n\t\t\t\t\t\tb: seg1.b,\n\t\t\t\t\t}]};\n\t\t\t\t\tmoves.push(move);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar ballRow=aGame.g.Coord[$this.ball][0];\n\t\t\tif((ballRow==0 && $this.mWho==JocGame.PLAYER_B) || (ballRow==HEIGHT-1 && $this.mWho==JocGame.PLAYER_A)) {\n\t\t\t\tvar touch=false;\n\t\t\t\tvar empty=0;\n\t\t\t\taGame.ScrumEachDirection($this.ball,function(pos) {\n\t\t\t\t\tif(pos==seg1.t)\n\t\t\t\t\t\ttouch=true;\n\t\t\t\t\telse if($this.board[pos]==-1)\n\t\t\t\t\t\tempty++;\n\t\t\t\t});\n\t\t\t\tif(touch && empty>0) {\n\t\t\t\t\tif(gotLevel1WinningSegment==false) {\n\t\t\t\t\t\tmoves=[];\n\t\t\t\t\t\tgotLevel1WinningSegment=true;\n\t\t\t\t\t}\n\t\t\t\t\tvar move={seg:[{\n\t\t\t\t\t\tf: seg1.f,\n\t\t\t\t\t\tt: seg1.t,\n\t\t\t\t\t}]};\n\t\t\t\t\tmoves.push(move);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(gotLevel1WinningSegment)\n\t\t\treturn;\n\t\tvar empty=0;\n\t\tvar ball=$this.ball;\n\t\tif(seg1.b!=null) ball=seg1.b;\n\t\tif(seg2.b!=null) ball=seg2.b;\n\t\taGame.ScrumEachDirection(ball,function(pos) {\n\t\t\tvar cell=$this.board[pos];\n\t\t\tif(cell<0)\n\t\t\t\tempty++;\n\t\t\tif(seg1.t==pos || seg2.t==pos)\n\t\t\t\tempty--;\n\t\t\tif(seg1.f==pos || seg2.f==pos)\n\t\t\t\tempty++;\n\t\t});\n\t\tif(empty==0) return;\n\t\t\n\t\tvar move={seg:[{\n\t\t\tf: seg1.f,\n\t\t\tt: seg1.t,\n\t\t},{\n\t\t\tf: seg2.f,\n\t\t\tt: seg2.t,\n\t\t}]};\n\t\tif(seg1.b!=null)\n\t\t\tmove.seg[0].b=seg1.b;\n\t\tif(seg2.b!=null)\n\t\t\tmove.seg[1].b=seg2.b;\n\t\tmoves.push(move);\n\t}\n\t\n\tvar iSegWT1=-1, iSegWT2=0;\n\tfunction GetNextSegmentPair() {\n\t\twhile(true) {\n\t\t\tiSegWT1++;\n\t\t\tif(iSegWT1==iSegWT2) {\n\t\t\t\tiSegWT2++;\n\t\t\t\tiSegWT1=0;\n\t\t\t}\n\t\t\tif(iSegWT2<segments.length) {\n\t\t\t\tvar seg1=segments[iSegWT1];\n\t\t\t\tvar seg2=segments[iSegWT2];\n\t\t\t\tif((seg1.b==null || seg2.b==null) && // filter: 2 level1 segments using same ball\n\t\t\t\t\t(seg1.i!=seg2.i) &&              // playing same piece\n\t\t\t\t\t(seg1.t!=seg2.t) &&              // same destination cell\n\t\t\t\t\t(seg2.t!=seg1.b || seg2.b!=null ) &&   // moving piece to ball\n\t\t\t\t\t(seg2.b!=seg1.t)                 // no ball to where first piece just move\n\t\t\t\t\t)\n\t\t\t\t\treturn [ seg1 , seg2 ];\n\t\t\t} else {\n\t\t\t\t// hopefully should not happen\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// get segments moving ball at level 2\n\tvar l2segmentsBallCache={}\n\tfunction GetLevel2BallSegments(ball) {\n\t\tif(typeof(l2segmentsBallCache[ball])==\"undefined\") {\n\t\t\tl2segmentsBallCache[ball]=[];\n\t\t\tvar avail=[];\n\t\t\tvar pieces=[];\n\t\t\taGame.ScrumEachDirection(ball,function(pos) {\n\t\t\t\tvar cell=$this.board[pos];\n\t\t\t\tif(cell==-1)\n\t\t\t\t\tavail.push(pos);\n\t\t\t\telse if(cell>=0 && $this.pieces[cell].s==$this.mWho) {\n\t\t\t\t\tpieces.push(cell);\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(var i in pieces) {\n\t\t\t\tvar index=pieces[i];\n\t\t\t\tfor(var j in avail) {\n\t\t\t\t\tl2segmentsBallCache[ball].push({\n\t\t\t\t\t\ti: index,\n\t\t\t\t\t\tf: $this.pieces[index].p,\n\t\t\t\t\t\tt: ball,\n\t\t\t\t\t\tb: avail[j],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn l2segmentsBallCache[ball];\n\t}\n\t\n\t// get segments moving to position\n\tvar l2segmentsPieceCache={}\n\tfunction GetLevel2PieceSegments(ppos) {\n\t\tif(typeof(l2segmentsPieceCache[ppos])==\"undefined\") {\n\t\t\tl2segmentsPieceCache[ppos]=[];\n\t\t\taGame.ScrumEachDirection(ppos,function(pos) {\n\t\t\t\tvar cell=$this.board[pos];\n\t\t\t\tif(cell>=0 && $this.pieces[cell].s==$this.mWho) {\n\t\t\t\t\tl2segmentsPieceCache[ppos].push({\n\t\t\t\t\t\ti: cell,\n\t\t\t\t\t\tf: $this.pieces[cell].p,\n\t\t\t\t\t\tt: ppos,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn l2segmentsPieceCache[ppos];\n\t}\n\t\n\tvar segs;\n\twhile(moves.length<aGame.mOptions.levelOptions.MIN_MOVES) { \n\t\tsegs=GetNextSegmentPair();\n\t\tif(segs) {\n\t\t\t//JocLog(\"Move\",m[0],m[1]);\n\t\t\t//AddMove(m[0],m[1]);\n\t\t\tvar seg1=segs[0];\n\t\t\tvar seg2=segs[1];\n\t\t\tAddMove(seg1,seg2);\n\t\t\tif(seg1.b!=null && !seg1.explored) { // ball moved at level 1\n\t\t\t\tseg1.explored=true;\n\t\t\t\t// consider ball move at level 2\n\t\t\t\tvar segments2=GetLevel2BallSegments(seg1.b);\n\t\t\t\tfor(var i in segments2) {\n\t\t\t\t\tvar segment2=segments2[i];\t\t\t\t\t\n\t\t\t\t\tif(segment2.i!=seg1.i) {\n\t\t\t\t\t\tAddMove(seg1,segment2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// consider moving piece to where 1st piece was\n\t\t\t\tvar segments2=GetLevel2PieceSegments(seg1.f);\n\t\t\t\tfor(var i in segments2) {\n\t\t\t\t\tvar segment2=segments2[i];\n\t\t\t\t\tif(segment2.i!=seg1.i) {\n\t\t\t\t\t\tAddMove(seg1,segment2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else \n\t\t\tbreak;\n\t}\n\t\n\t// add moves where seg1 moves piece only and seg2 moves ball to where first piece was\n\tvar piecesAround=[];\n\taGame.ScrumEachDirection(this.ball,function(pos) {\n\t\tvar cell=$this.board[pos];\n\t\tif(cell>=0 && $this.pieces[cell].s==$this.mWho)\n\t\t\tpiecesAround.push(cell);\n\t});\n\tvar piecesAround1=[];\n\tfor(var i in piecesAround) { // do not consider moves with ball behind\n\t\tvar row=aGame.g.Coord[this.pieces[piecesAround[i]].p][0];\n\t\tif((this.mWho==JocGame.PLAYER_A && row>=ballRow) ||\n\t\t\t\t(this.mWho==JocGame.PLAYER_B && row<=ballRow))\n\t\t\tpiecesAround1.push(piecesAround[i]);\n\t}\n\tvar movesLength0=moves.length;\n\tfor(var i in piecesAround1)\n\t\tfor(var j in piecesAround) {\n\t\t\tif(piecesAround1[i]!=piecesAround[j]) {\n\t\t\t\tvar piece1=this.pieces[piecesAround1[i]];\n\t\t\t\tvar piece2=this.pieces[piecesAround[j]];\n\t\t\t\taGame.ScrumEachDirection(piece1.p,function(pos) {\n\t\t\t\t\tvar cell=$this.board[pos];\n\t\t\t\t\tif(cell==-1) {\n\t\t\t\t\t\tvar seg1={\n\t\t\t\t\t\t\ti: piecesAround1[i],\n\t\t\t\t\t\t\tf: piece1.p,\n\t\t\t\t\t\t\tt: pos,\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar seg2={\n\t\t\t\t\t\t\ti: piecesAround[j],\n\t\t\t\t\t\t\tf: piece2.p,\n\t\t\t\t\t\t\tt: $this.ball,\n\t\t\t\t\t\t\tb: piece1.p,\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//JocLog(\"group2 move\",seg1,seg2);\n\t\t\t\t\t\tAddMove(seg1,seg2);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\tvar group2Moves=moves.length-movesLength0;\n\t\n\tthis.mMoves=moves;\n\t\n\tif(this.mMoves.length==0) {\n\t\t// always have one 'bad' but legal move possible to prevent no move found\n\t\tfunction MakeLooseMove() {\n\t\t\tvar looseMove=null;\n\t\t\tvar looseData=[];\n\t\t\tvar piecesDist=[];\n\t\t\tEachPiece(function(index,pos) {\n\t\t\t\tvar d=Dist(pos,$this.ball);\n\t\t\t\tpiecesDist.push({\n\t\t\t\t\ti: index,\n\t\t\t\t\td: d,\n\t\t\t\t});\n\t\t\t});\n\t\t\tpiecesDist.sort(function(a,b) {\n\t\t\t\treturn b.d-a.d;\n\t\t\t});\n\t\t\tfor(var i in piecesDist) {\n\t\t\t\tvar piece=piecesDist[i];\n\t\t\t\tvar pos=$this.pieces[piece.i].p;\n\t\t\t\tvar d0=Dist(pos,$this.ball);\n\t\t\t\tvar abortEachDir=false;\n\t\t\t\taGame.ScrumEachDirection(pos,function(npos) {\n\t\t\t\t\tif(abortEachDir)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif($this.board[npos]==-1) {\n\t\t\t\t\t\tvar d=Dist(npos,$this.ball);\n\t\t\t\t\t\tif(d>=d0) {\n\t\t\t\t\t\t\tif(looseData.length==1 && npos==looseData[0].t) return;\n\t\t\t\t\t\t\tlooseData.push({\n\t\t\t\t\t\t\t\ti: piece.i,\n\t\t\t\t\t\t\t\tf: pos,\n\t\t\t\t\t\t\t\tt: npos,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tabortEachDir=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(looseData.length==2) {\n\t\t\t\t\tlooseMove={seg:[{\n\t\t\t\t\t\tf: looseData[0].f,\n\t\t\t\t\t\tt: looseData[0].t,\n\t\t\t\t\t},{\n\t\t\t\t\t\tf: looseData[1].f,\n\t\t\t\t\t\tt: looseData[1].t,\n\t\t\t\t\t}]};\n\t\t\t\t\treturn looseMove;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.mMoves.push(MakeLooseMove());\n\t}\n\t\n\tgmStats = (typeof(gmStats)!=\"undefined\") ? gmStats : {\n\t\tcount: 0,\n\t\ttime: 0,\n\t\tmoves: 0,\n\t\tsegments: 0,\n\t\tmaxGroup2: 0,\n\t}\n\tvar time1 = new Date().getTime();\n\tvar deltaTime = time1 - time0;\n\t\n\tgmStats.count++;\n\tgmStats.time+=deltaTime;\n\tgmStats.moves+=moves.length;\n\tgmStats.segments+=segments.length;\n\t\n\tif(group2Moves>gmStats.maxGroup2) {\n\t\tgmStats.maxGroup2=group2Moves;\n\t\t//JocLog(\"Group2\",group2Moves);\n\t}\n\t\n\t//JocLog(\"Duration\",deltaTime,\"ms\",gmStats.time/gmStats.count,\"moves\",moves.length,gmStats.moves/gmStats.count,\"segments\",segments.length,gmStats.segments/gmStats.count);\n\n\t//JocLog(\"segments\",segments.length,segments);\n\t//JocLog(\"moves\",this.mMoves);\n\t\n\t//JocLog(\"-----------------------------------------\");\n}\n\n/* Optional method.\n */\n/*\nModel.Board.QuickEvaluate = function(aGame) {\n\treturn this.EvaluateChessBoard(aGame);\n}\n*/\n\n/* The Evaluate method must:\n * - detects whether the game is finished by setting mFinished to true, and determine the winner by assigning\n * mWinner (to JocGame.PLAYER_A, JocGame.PLAYER_B, JocGame.DRAW).\n * - calculate mEvaluation to indicate apparent advantage to PLAYER_A (higher positive evaluation) or to\n * PLAYER_B (lower negative evaluation)\n * Parameters:\n * - aFinishOnly: it is safe to ignore this parameter value, but for better performance, the mEvaluation setting\n * can be skipped if aFinishOnly is true (function caller is only interested if the game is finished).\n * - aTopLevel: it is safe to ignore this parameter value. For convenience, if true, there is no performance involved \n * so it is safe to make additional calculation and storing data, for instance to simplify the display of the last move.\n */\nModel.Board.Evaluate = function(aGame,aFinishOnly,aTopLevel) {\n\n\tif(aGame.GetRepeatOccurence(this)>2) {\n\t\tthis.mFinished=true;\n\t\tthis.mWinner=JocGame.DRAW;\n\t\treturn;\n\t}\n\n\tvar HEIGHT=aGame.mOptions.height;\n\tvar $this=this;\n\n\tvar emptyCount=0;\n\tvar aCount=0;\n\tvar bCount=0;\n\n\taGame.ScrumEachDirection(this.ball,function(pos) {\n\t\tvar cell=$this.board[pos];\n\t\tif(cell==-1)\n\t\t\temptyCount++;\n\t\telse if(cell>=0) {\n\t\t\tvar piece=$this.pieces[cell];\n\t\t\tif(piece.s==JocGame.PLAYER_A) {\n\t\t\t\taCount++;\n\t\t\t} else {\n\t\t\t\tbCount++;\n\t\t\t}\n\t\t\tif(ballRow==0 && piece.p==JocGame.PLAYER_B) {\n\t\t\t\t$this.mFinished=true;\n\t\t\t\t$this.mWinner=JocGame.PLAYER_B;\n\t\t\t} else if(ballRow==HEIGHT-1 && piece.p==JocGame.PLAYER_A) {\n\t\t\t\t$this.mFinished=true;\n\t\t\t\t$this.mWinner=JocGame.PLAYER_A;\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar ballRow=aGame.g.Coord[this.ball][0];\n\tif(ballRow==0 && bCount>0) {\n\t\t$this.mFinished=true;\n\t\t$this.mWinner=JocGame.PLAYER_B;\n\t}\n\tif(ballRow==HEIGHT-1 && aCount>0) {\n\t\t$this.mFinished=true;\n\t\t$this.mWinner=JocGame.PLAYER_A;\n\t}\n\t\n\tvar rowCloseA=ballRow/(HEIGHT-1);\n\tvar rowCloseB=1-rowCloseA;\n\tvar rowClose=rowCloseA-rowCloseB;\n\t\n\tvar neighbor=0;\n\tif(bCount==0)\n\t\tneighbor++;\n\tif(aCount==0)\n\t\tneighbor--;\n\t\n\tvar aBDist=0;\n\tvar bBDist=0;\n\tvar bCoord=aGame.g.Coord[this.ball];\n\tfor(var i in this.pieces) {\n\t\tvar piece=this.pieces[i];\n\t\tvar coord=aGame.g.Coord[piece.p];\n\t\tvar d=Math.max(Math.abs(bCoord[0]-coord[0]),Math.abs(bCoord[1]-coord[1]));\n\t\tif(piece.s==JocGame.PLAYER_A) {\n\t\t\taBDist+=d;\n\t\t} else {\n\t\t\tbBDist+=d;\n\t\t}\n\t}\n\t\n\tthis.mEvaluation=\n\t\t(rowClose * aGame.mOptions.levelOptions.ROW_FACTOR) +\n\t\t(neighbor * aGame.mOptions.levelOptions.NEIGHBOR_FACTOR) +\n\t\t((bBDist-aBDist) * aGame.mOptions.levelOptions.BDIST_FACTOR)\n\t;\n\n\t//JocLog(\"Evaluate\",this.mEvaluation,\"neighbor\",neighbor,\"row\",rowClose,\"abdist\",aBDist,\"bbdist\",bBDist);\n}\n\n/* Optional method.\n * Copy the given board data to self.\n * Even if optional, it is better to implement the method for performance reasons. \n */\nModel.Board.CopyFrom = function(aBoard) {\n\tthis.board=[];\n\tfor(var pos=0;pos<aBoard.board.length;pos++)\n\t\tthis.board.push(aBoard.board[pos]);\n\tthis.pieces=[];\n\tfor(var i=0;i<aBoard.pieces.length;i++) {\n\t\tvar piece=aBoard.pieces[i];\n\t\tthis.pieces.push({\n\t\t\ts: piece.s,\n\t\t\tp: piece.p,\n\t\t\ta: piece.a,\n\t\t\tsc: piece.sc,\n\t\t});\n\t}\n\tthis.ball=aBoard.ball;\n\tthis.scrum=aBoard.scrum;\n\tthis.first=aBoard.first;\t\n\tthis.mWho=aBoard.mWho;\n\tthis.zSign=aBoard.zSign;\n}\n\n/* Modify the current board instance to apply the move.\n */\nModel.Board.ApplyMove = function(aGame,move) {\n\t//JocLog(\"ApplyMove \"+JSON.stringify(move)+\" \"+JSON.stringify(this));\n\tvar $this=this;\n\t\n\tvar piece0=this.board[move.seg[0].f];\n\tif(piece0<0) {\n\t\tJocLog(\"!!! ApplyMove\",move,this.board,\"seg0: no piece at start\");\n\t\treturn;\n\t}\n\tif(this.pieces[piece0].s!=this.mWho) {\n\t\tconsole.error(\"!!! ApplyMove\",move,this.board,\"seg0: piece at start is not self\");\n\t\treturn;\n\t}\n\tvar pto0=this.board[move.seg[0].t];\n\tif(pto0!=-1 && pto0!=-2) {\n\t\tJocLog(\"!!! ApplyMove\",move,this.board,\"seg0: cell at dest not avail\",pto0);\n\t\treturn;\n\t}\n\tif(pto0==-2) {\n\t\tif(typeof(move.seg[0].b)==\"undefined\") {\n\t\t\tJocLog(\"!!! ApplyMove\",move,this.board,\"seg0: to ball but no ball depl\");\n\t\t\treturn;\n\t\t}\n\t}\n\tif(pto0!=-2) {\n\t\tif(typeof(move.seg[0].b)!=\"undefined\") {\n\t\t\tJocLog(\"!!! ApplyMove\",move,this.board,\"seg0: no ball but ball depl\");\n\t\t\treturn;\n\t\t}\n\t}\n\tvar seg=move.seg[0];\n\tvar pIndex=this.board[seg.f];\n\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",this.mWho,seg.f);\n\tthis.board[seg.f]=-1;\n\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",this.mWho,seg.t);\n\tthis.board[seg.t]=pIndex;\n\tthis.pieces[piece0].p=seg.t;\n\tif(seg.b!==undefined) {\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",-2,this.ball);\n\t\tthis.ball=seg.b;\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",-2,this.ball);\n\t\tthis.board[this.ball]=-2;\n\t}\n\t\n\tif(typeof(move.seg[1])!=\"undefined\") {\n\t\tvar piece1=this.board[move.seg[1].f];\n\t\tif(piece0==piece1) {\n\t\t\tJocLog(\"!!! ApplyMove\",move,this.board,\"seg1: move same piece\");\n\t\t\treturn;\n\t\t}\n\t\tif(piece1<0) {\n\t\t\tJocLog(\"!!! ApplyMove\",move,this.board,\"seg1: no piece at start\");\n\t\t\tJocLog(move,this);\n\t\t\treturn;\n\t\t}\n\t\tif(this.pieces[piece1].s!=this.mWho) {\n\t\t\tJocLog(\"!!! ApplyMove\",move,this.board,\"seg1: piece at start is not self\");\n\t\t\treturn;\n\t\t}\n\t\tvar pto1=this.board[move.seg[1].t];\n\t\tif(pto1!=-1 && pto1!=-2) {\n\t\t\tJocLog(\"!!! ApplyMove\",move,this.board,\"seg1: cell at dest not avail\");\n\t\t\treturn;\n\t\t}\n\t\tif(pto1==-2) {\n\t\t\tif(typeof(move.seg[1].b)==\"undefined\") {\n\t\t\t\tJocLog(\"!!! ApplyMove\",move,this.board,\"seg1: to ball but no ball depl\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(pto1!=-2) {\n\t\t\tif(typeof(move.seg[1].b)!=\"undefined\") {\n\t\t\t\tJocLog(\"!!! ApplyMove\",move,this.board,\"seg1: no ball but ball depl\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tvar seg=move.seg[1];\n\t\tvar pIndex=this.board[seg.f];\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",this.mWho,seg.f);\n\t\tthis.board[seg.f]=-1;\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",this.mWho,seg.t);\n\t\tthis.board[seg.t]=pIndex;\n\t\tthis.pieces[piece1].p=seg.t;\n\t\tif(seg.b!==undefined) {\n\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",-2,this.ball);\n\t\t\tthis.ball=seg.b;\n\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",-2,this.ball);\n\t\t\tthis.board[this.ball]=-2;\n\t\t}\n\t}\n\t\n\t// detect scrum\n\tvar emptyCount=0;\n\taGame.ScrumEachDirection(this.ball,function(pos){\n\t\tif($this.board[pos]==-1) {\n\t\t\temptyCount++;\n\t\t\t$this.scrumExit=pos;\n\t\t}\n\t});\n\t\n\tthis.scrum=false;\n\tif(emptyCount==1) {\n\t\tthis.scrum=true;\n\t} else if(emptyCount==0) {\n\t\tJocLog(\"!!! ApplyMove: ball enclosed\");\n\t}\n\t\n\tvar scrummers={};\n\tif(this.scrum) {\n\t\taGame.ScrumEachDirection(this.ball,function(pos,dir) {\n\t\t\tvar pIndex=$this.board[pos];\n\t\t\tif(pIndex>=0)\n\t\t\t\tscrummers[pIndex]=dir;\n\t\t});\n\t}\n\tfor(var i=0;i<this.pieces.length;i++) {\n\t\tvar piece=this.pieces[i];\n\t\tvar angle=0;\n\t\tif(scrummers[i]!==undefined) {\n\t\t\tangle=[135,180,-135,90,-90,45,0,-45][scrummers[i]];\n\t\t\tpiece.a=angle;\n\t\t\tpiece.sc=true;\n\t\t} else {\n\t\t\tpiece.a=angle+(piece.s==1?180:0);\n\t\t\tpiece.sc=false;\n\t\t}\n\t}\n\t\n\tthis.first=false;\n\t\n\t//JocLog(\"Applied Move \"+JSON.stringify(this));\n}\n\t\nModel.Board.IsValidMove = function(aGame,move) {\n\t//JocLog(\"IsValidMove\",move);\n\tvar $this=this;\n\tvar empty=0;\n\tvar ball=this.ball;\n\tvar seg1=move.seg[0];\n\tvar seg2=move.seg[1];\n\tif(seg1.b) ball=seg1.b;\n\tif(seg2 && seg2.b) ball=seg2.b;\n\taGame.ScrumEachDirection(ball,function(pos) {\n\t\tvar cell=$this.board[pos];\n\t\tif(cell<0)\n\t\t\tempty++;\n\t\tif(seg1.t==pos || (seg2 && seg2.t==pos))\n\t\t\tempty--;\n\t\tif(seg1.f==pos || (seg2 && seg2.f==pos))\n\t\t\tempty++;\n\t});\n\tif(empty==0) {\n\t\tthis.mInvalidMoveMessage=aGame.mStrings['no-surround'];\n\t\treturn false;\n\t} else\n\t\treturn true;\n}\n\nModel.Board.GetSignature = function() {\n\treturn this.zSign;\n}\t\n\t\n"],"file":"scrum-model.js"}